/*
	DYNAMIC OBFUSCATOR L FOR AUTOHOTKEY
	Adapted by DigiDon
	Based on DYNAMIC OBFUSCATOR - Copyright (C) 2011-2013 David Malia
	
	DYNAMIC OBFUSCATOR is an obfuscator for autohotkey scripts that
	can obfuscate functions, autohotkey functions, labels,
	parameters, and variables. It can automatically use the dynamic
	variable creation features of autohotkey to create breakable
	code sections and function path rewiring.

	This program is free software: you can redistribute it and/or 
	modify it under the terms of the GNU General Public License as
	published by the Free Software Foundation, either version 3 of
	the License, or (at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see
	<http://www.gnu.org/licenses/>.

	David Malia, 11 Cedar Ct, Augusta ME, USA
	dave@dynamicobfuscator.org
	http://davidmalia.com
	
	Modified by DigiDon
	https://autohotkey.com/boards/memberlist.php?mode=viewprofile&u=59397
*/



createTRANSMAP() {
	global
	
	;ADDED DIGIDON : timer
	starttime_createTransMAP:=A_Tickcount
	;DIGIDON ADDED counttotalMAPLines
	counttotalMAPLines=0
	
	createTRANSMAPmesswin()
	
	FileRead, fileslist, % myfileslistfile
		
	FormatTime, currenttime
	
	writetoMAPfilestr=
	
	MAPfilestr =
(

	OBFUSCATOR FIND FUNCTION AND LABEL HEADERS MAP OUTPUT FILE
	Date: %currenttime%

	This is an automatically generated 'map' of the sections (functions, labels, 
	context conditions, hotkeys, classes...)
	found in the ahk source files specified by the user.
	This file can be used as the beginning point in the next step of obfuscation
	of the source files - the actual obfuscation!
	
	For each section that is found in the source code files, one of the 2 obfuscator
	commands below will be printed	in this file.
	Only the current section name will be supplied by this 
	program, the other parameters will use the current 'defaults'. To use different
	values than the current defaults, just add them to the obfuscator command
	generated by this program for that section definition.
	That will then change the 'defaults' for all subsequent commands that do not
	supply new values.
	
	ex: For functions and labels
	$DEFFUNC: func name, new func name size min/max, divide into num frags,
		 number frag sets, frag var size min/max, add null frags
	$DEFLABEL: label name, new label name size min/max, divide into num frags,
	 number frag sets, frag var size min/max, add null frags
	 
	#FILE IN WHICH THE LIST OF SOURCE CODE FILES TO PROCESS WAS RETRIEVED:
	%myfileslistfile%
	 
	#LIST OF FILES FOUND IN THAT FILE:

%fileslist%

	#OUTPUT FILE NAME(this file):
	%myMAPfilename%
)
	writetoMAPfile(MAPfilestr)
	
	initOBFdefaults()
	init_changedefaultsCOMMs()
	
	MAPfilestr = 
(	
	    
	Change the values assigned to the program start defaults below to use
	different starting values when this map file is input to the obfuscator.

)
	writetoMAPfile(MAPfilestr)
	
	;write out all default values
	loop, % numvartypes
	{
		curdeftype = % vartype%a_index%
		loop, % numdefaultprop
		{
			curdefprop = % defaultprop%a_index%
			fullpropname = %curdeftype%_%curdefprop%
			writetoMAPfile("#StartDefault: " . fullpropname . ", " . %fullpropname%)
		}
		writetoMAPfile("")
	}
		
	totalsourcelines = 0
	
	;after label sections and function are 'broken off'
	;this is the function name that will be called to process it
	;this can have 2 different values
	processcodesection = % "MAPcodesection"
	
	;TWEAKED DIGIDON : TURN TO NEW PARSE FCT
	ParseIncludeList(fileslist)
	
	;ADDED DIGIDON : timer
	endtime_createTransMAP:=A_TickCount
	timepassed_createTransMAP:=endtime_createTransMAP-starttime_createTransMAP
	timepassed_createTransMAP_totalsc_ct:=ROUND(timepassed_createTransMAP/1000,2)
	timepassed_createTransMAP_mn:=ROUND(timepassed_createTransMAP_totalsc_ct) // 60
	timepassed_createTransMAP_sc:= Mod(ROUND(timepassed_createTransMAP_totalsc_ct), 60)
	timepassed_createTransMAP_ct:=(timepassed_createTransMAP - timepassed_createTransMAP_sc * 60)
	
	;TWEAKED DIGIDON
	msgbox, % "Total source code lines processed: " totalsourcelines " in " timepassed_createTransMAP_totalsc_ct " seconds"
	closeMAPfile()
			
	showmyprocmess("Total source code lines processed: " . totalsourcelines)
	
	return
}

;ADDED DIGIDON ParseIncludeList
ParseIncludeList(fileslist) {
global curfilenum
	AA_Index=0
	Loop, parse, fileslist, `n, `r
	{
		;ADDED DIGIDON BETTER INCLUDEFILE
		if Trim(A_LoopField="")
		continue
		
		if (SubStr(A_LoopField,1,1)=";")
		{
		continue
		}
		
		If !FileExist(A_LoopField)
			{
			TrimLoopField=%A_LoopField%
			msgbox,
			(LTrim
			"%TrimLoopField%"
			in Include file cannot be found or is not a valid filepath.
			
			Make sure you selected a home-made file (call it "scriptname_includemap.txt" for example) with the list of the files to obfuscate, starting with your main script and continuing with your include files. 
			See documentation if needed.
			)
			exitapp
			}
		if InStr(FileExist(A_LoopField), "D")
			{
			SetWorkingDir, %A_LoopField%
			continue
			}
		AA_Index++
		curfilenum = %  AA_Index
		;file name and the number it is in the list
		parse_onefile(A_LoopField, AA_Index)				
	}
}

MAPcodesection(preLOFlines, ByRef LOFheaderline, ByRef LOFbodylines, LOFtype, LOFname)
{
	;LOCAL
	local NestedFctLine
	

	if (LOFtype = "label") 			
		mysecttype = % "label:global"
	else if (LOFtype = "hotkey") 
		mysecttype = % "label:hotkey"
	else if (LOFtype = "function") 
		mysecttype = % "function"
	else if (LOFtype = "autoexecute")
		mysecttype = % "label:autoexecute"
	;ADDED DIGIDON #IF contextcondition		
	else if (LOFtype = "contextcondition")
		mysecttype = % "contextcondition"
	;ADDED DIGIDON Classes	
	else if (LOFtype = "class")
		mysecttype = % "class"	


	;the routine below will slow down the program enormously!
	;showmyprocmess("MAPPING CODE SECTION: " . mysecttype, LOFheaderline)

	writeLOFtoTRANSMAP(preLOFlines, LOFheaderline, LOFtype,  LOFname)
	LOFnameBK:=LOFname
	
	LOFtype2=
	NestedFctLines=
		;ADDED DIGIDON NESTED FUNCTION : need to store all lines and repeat until no more found
		NestedFctLines:=isNestedFctInside(LOFbodylines, LOFtype2, LOFsnames)
	
	;look for nested label tags
	Loop, parse, LOFbodylines, `n, `r
	{
		;TWEAKED DIGIDON
		LOFname := LOFnameBK
		preLOFlines =
		if IS_OBFCOMM(A_Loopfield) {
			passthruCOMM(LOFtype)
			continue
		}
		LOFtype2 =
		
		
		AA_Loopfield:=Trim(A_Loopfield)
		AA_Index:=A_Index
		Loop, parse, NestedFctLines, |
		if (AA_Index=A_LoopField) {
			LOFname:= Getting_ValueChosenFromList(A_Index,LOFsnames)
			LOFtype2:="method"
			showmyprocmess("  *NESTED METHOD FOUND: " . LOFname)
			writeLOFtoTRANSMAP(preLOFlines, AA_Loopfield, LOFtype2, LOFname, "NESTEDMETHOD")
		}
		
		if (isLOFheader(A_Loopfield, LOFtype2, LOFname, 1) and LOFtype2 = "label") {
			showmyprocmess("  *NESTED LABEL FOUND: " . LOFname)
			writeLOFtoTRANSMAP(preLOFlines, A_Loopfield, LOFtype2, LOFname, "NESTEDLABEL")
		}
		;ADDED DIGIDON NESTED HOTKEY
		else if (isLOFheader(A_Loopfield, LOFtype2, LOFname, 1) and LOFtype2 = "hotkey") {
			showmyprocmess("  *NESTED HOTKEY FOUND: " . LOFname)
			writeLOFtoTRANSMAP(preLOFlines, A_Loopfield, LOFtype2, LOFname, "NESTEDHK")
		}
		;ADDED DIGIDON NESTED CLASS
		else if (isLOFheader(A_Loopfield, LOFtype2, LOFname, 1, 1) and LOFtype2 = "class") {
		; msgbox NESTED CLASS FOUND
			showmyprocmess("  *NESTED CLASS FOUND: " . LOFname)
			writeLOFtoTRANSMAP(preLOFlines, A_Loopfield, LOFtype2, LOFname, "NESTEDCLASS")
		}
	}

}

;check for all obfuscater commands that might be in the source code
;that i need to 'pass through' and put in the translations map
passthruCOMM(cursectiontype = "") {
	global	
	
	;ADDED DIGIDON : COMMENT TO STOP OBF
	if isstopobfCOMM(CUR_OBFCOMM) {
		; msgbox stopobfcomm
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;ADDED DIGIDON : COMMENT TO FORCE STRAIGHT OBF
	if isobfmodeCOMM(CUR_OBFCOMM) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;ADDED DIGIDON : COMMENT TO KEEP COMMENT
	if iskeepcommCOMM(CUR_OBFCOMM) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;ADDED DIGIDON : BLOCK COMMENT
	if isblockCOMM(CUR_OBFCOMM) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	if ischangedefaultsCOMM(CUR_OBFCOMM) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	if (CUR_OBFCOMM = create_objsCLASS or CUR_OBFCOMM = add_followingtoCLASS) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	if (CUR_OBFCOMM	= restoreallCOM) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;DEFINE GLOBALS OR SYSTEM FUNCTIONS
	if (CUR_OBFCOMM	= def_SYSFUNCS or CUR_OBFCOMM = def_GLOBVARS) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;ADDED DIGIDON GLOBPARTIALVARS
	;DEFINE PARTIAL GLOBALS
	if (CUR_OBFCOMM	= def_GLOBPARTIALVARS) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}	
	
	;ADDED DIGIDON PROPERTIES
	;DEFINE SUPER GLOBALS
	if (CUR_OBFCOMM	= def_PROPERTIES) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;DEFINES THE ORDER IN WHICH TO DUMP FUNCTION AND LABEL SOURCE CODE
	if (CUR_OBFCOMM	= "DUMP_CLASSCODE") {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;alows me to 'rewire' calls to functions so that a call to a function
	;will go to a different function!!
	if (CUR_OBFCOMM	= "DUMP_REWIREFUNCPATH") {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	;SPECIAL CASE when the gui, +Label????? is used with a gui
	if (CUR_OBFCOMM	= "DEFGUILAB") {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return	
	}
	
	if (CUR_OBFCOMM = def_PARAMS) {
		;'pass through' this command and put it in the translations map
		writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		return
	}
			
	;these 2 commands are only allowed inside a function
	;DEFINE LOCAL OR STATIC OR DEFINE FUNCandVAR
	if (CUR_OBFCOMM	= def_LOSVARS or CUR_OBFCOMM = def_FUNCandVARS) 
	{
		if (cursectiontype = "function") {
			;'pass through' this command and put it in the translations map
			writetoMAPfile("`r`n$" . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
			return
		} else {
			;these 2 commands are only allowed inside a function and they
			;were found outside
			writetoMAPfile("`r`n#ERROR: COMMAND FOUND OUTSIDE FUNC BODY THAT IS NOT ALLOWED THERE")
			writetoMAPfile("#COMMAND FOUND: " . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
			return
		}
	}
	;ADDED DIGIDON ALLOW COMMMENTS in TRANSMAP
	else
		{
		writetoMAPfile("#OTHER COMMAND FOUND: " . CUR_OBFCOMM . ": " . CUR_COMMPARAMS)
		}
}

getcommparams()
{
	global
	local passparams
	
	return, % CUR_COMMPARAMS
	
	passparams =
	loop, % numOBFcomms
	{
		 if (a_index <> 1)
			OBFcommstr .= " / "
		 passparams .= obfparam%a_index%				
	}
	return, % passparams
}


writeLOFtoTRANSMAP(preLOFlines, LOFheaderline, LOFtype, LOFname, specialcase = "")
{
		
	writetoMAPfile("")
	if preLOFlines is not space
		writetoMAPfile(preLOFlines)
			
	if (LOFtype = "autoexecute") {
		writetoMAPfile("#FOUND: *AUTOEXECUTE SECTION FOUND*") 
		return		
	}
	
	if (LOFtype = "function")
		OBFfunc = % "$DEFFUNCS: "	
	else if (LOFtype = "label")
		OBFfunc = % "$DEFLABELS: "
	;TWEAKED DIGIDON : DEF HOTKEYS INSTEAD OF LABELS
	else if (LOFtype = "hotkey")
		OBFfunc = % "$DEFHOTKEYS: "
	;ADDED DIGIDON #IF CONDITION
	else if (LOFtype = "contextcondition")
		OBFfunc = % "$DEFCOND: "
	;ADDED DIGIDON METHODS
	else if (LOFtype = "method")
		OBFfunc = % "$DEFMETHODS: "
	;ADDED DIGIDON Classes
	else if (LOFtype = "class")
		OBFfunc = % "$DEFCLASS: "
	else {
		writetoMAPfile("`r`n;*LOFtype ERROR* LOFtype: " . LOFtype . " funcorlabelname: " . LOFname . "`r`n")
		return
	}
	;ADDED DIGIDON NESTED HOTKEY
	if (specialcase = "NESTEDLABEL")
		writetoMAPfile("#NESTED LABEL FOUND#")
	;ADDED DIGIDON NESTED HOTKEY
	else if (specialcase = "NESTEDHK")
		writetoMAPfile("#NESTED HOTKEY FOUND#")
	;ADDED DIGIDON NESTED CLASS
	else if (specialcase = "NESTEDCLASS")
		writetoMAPfile("#NESTED CLASS FOUND#")
	;ADDED DIGIDON NESTED FUNCTION
	else if (specialcase = "NESTEDMETHOD")
		writetoMAPfile("#NESTED METHOD FOUND#")
	
	writetoMAPfile("#FOUND: " . LOFheaderline)
	
	writetoMAPfile(OBFfunc . LOFname)
	
	;TWEAKED DIGIDON PARAMS FOR METHODS
	;if it is a function, parse out any parameters found and 
	;write 'map' tags for those as well
	if (LOFtype = "function" or LOFtype = "method") {
		paramslist = % substr(LOFheaderline, (strlen(LOFname) + 2))
		closingpar = % instr(paramslist, ")")
		if (!closingpar) {
			writetoMAPfile("# *PARAMETERS ERROR*")
			return		
		}
		paramslist = % substr(paramslist, 1, (closingpar - 1))
				
		Loop, Parse, paramslist, `,, %A_Space%%A_Tab%
		{
			myparam = % A_Loopfield
			
			first6chars = % substr(myparam, 1, 6)
			StringUpper, first6chars, first6chars
			if (first6chars = "BYREF ")
				myparam = % substr(myparam, 7)
			
			;TWEAKED DIGIDON : ALLOW ":=" in declarations
			foundequal2 := instr(myparam, ":=")
			foundequal := instr(myparam, "=")
			if foundequal2
			foundequal:=foundequal2
			 
			if (foundequal) {
				myparam = % substr(myparam, 1, (foundequal - 1))
				;removes any excess spaces
				myparam = %myparam%
			}			
			
			;ADDED DIGIDON UNCOMPLETE : DISCARD FOR NOW VARIADIC PARAMS (because should be considered object uses)
			if (substr(myparam,0)="*") {
			continue
			}
			
			;DIGIDON MAYBE SPECIAL CASE FOR METHODS?
			writetoMAPfile("$DEFPARAMS: " . myparam)
		}	
	}	
}

createTRANSMAPmesswin()
{
	global
	
	gui 10:default
	
	gui, margin, 40, 20
	
	gui, font, %scl_basefont%  norm
	gui, add, text, xm ym vgetspacewidth, % " "
	GuiControlGet, spacewidth, Pos, getspacewidth
	
	gui, font, %scl_h1font% bold
	gui, add, text, xp yp, Mapping Functions and Label Sections in Source Code 
	
	editwidth = % "W" . (spacewidthW * 140)
	
	gui, font, %scl_basefont%  norm
	
	gui, add, text, xm y+30, Source code file name being processed
	gui, add, edit, xm y+4 readonly Vshowscodefilename %editwidth% C009900
	
	;gui, add, text, xm y+30, Processing messages
	;gui, add, edit, xm y+4 R6 readonly Vshowprocessmess %editwidth% C009900
	
	gui, add, text, xm y+20
	
	gui, add, button, xm+30 yp GchooseOBFfunc, Choose OBF fuction
	
	gui, show,, Mapping Source Code Files
}

showmyprocmess(message, funcorlabelname = "")
{	
	global curfilenum
	
	static allmesslines := ""
	
	IF (funcorlabelname)
		showfuncname = % "  name: " . funcorlabelname
	else
		showfuncname = % ""
		
	allmesslines .= "file#" . curfilenum . "  " . message . showfuncname  . "`r`n" 
	
	;write file name to window that shows 'running' info
	;THE STATEMENT BELOW WILL SLOW DOWN THE PROGRAM BIG TIME!
	;GuiControl,, showprocessmess, % allmesslines	
}



writetoMAPfile(writethis)
{
	global
	
	if (!writetoMAPfilestr)
		 VarSetCapacity(writetoMAPfilestr, 120000)
		 
	writetoMAPfilestr .= writethis . "`r`n"
	
}
closeMAPfile() {
	global	
	
	;delete if already exists
	;DIGIDON ADDED counttotalMAPLines
	
	counttotalMAPLines+=countlines(writetoMAPfilestr)
		writetoMAPfile(";TOTAL MAP LINES:" counttotalMAPLines)
	writetoMAPfile(";TOTAL SOURCE LINES:" totalsourcelines)
	FileDelete, % myMAPfilename	
	FileAppend, % writetoMAPfilestr, % myMAPfilename	
}

